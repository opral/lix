# Architectural Review: SQL Execution Pipeline

## Executive Summary

The SQL execution pipeline suffers from a **path explosion problem**: the same SQL can take 5+ different execution paths depending on runtime conditions, each path independently handling parsing, parameter binding, side effects, preprocessing, execution, and cache invalidation. These paths have **subtle behavioral differences** that are the root cause of recurring regressions.

The single most dangerous pattern: **parameters are bound twice** in the transaction script path — once in `scripts.rs` to split them across statements, then again in `pipeline.rs` when each statement is individually preprocessed. This double-binding is the primary source of parameter-related regressions.

---

## The 5 Execution Paths

Every SQL statement entering `Engine::execute()` can follow one of these paths:

```
Engine::execute(sql, params)
│
├─ PATH 1: Transaction Script (BEGIN...COMMIT detected)
│  └─ scripts.rs → bind params per-statement → for each:
│     └─ PATH 3: in_transaction.rs → full pipeline again
│
├─ PATH 2: Direct (single/multi statement, no explicit txn)
│  └─ entry.rs → preprocess → execute_prepared
│  └─ if preprocess fails → PATH 4: Sequential Fallback
│
├─ PATH 3: In-Transaction (called per-statement from PATH 1 or transaction API)
│  └─ in_transaction.rs → full pipeline → execute in txn
│  └─ if preprocess fails → PATH 4b: Sequential Fallback in Txn
│
├─ PATH 4: Sequential Fallback (multi-statement postprocess error)
│  └─ fallback.rs → split statements → re-enter PATH 2 or PATH 3 for each
│
└─ PATH 5: Transaction API (engine.transaction(|tx| ...) callback)
   └─ transaction.rs → user calls tx.execute() → PATH 3
```

### Why This Is Regression-Prone

Each path independently makes decisions about:
- Whether to collect side effects (and when)
- Whether to defer side effects
- How to bind parameters
- How to handle preprocessing errors
- Whether to wrap in a transaction
- How to persist file domain changes
- How to invalidate caches

A change to any of these concerns in one path must be manually replicated across all paths. Missing one path = regression.

---

## Root Cause #1: Double Parameter Binding

The most critical architectural flaw. When `BEGIN; DELETE ...; INSERT ...; COMMIT;` is executed with parameters:

**Step 1** — `scripts.rs:114-127`: Binds `?` placeholders using `PlaceholderState` to split 7 params across 3 statements:
```
Statement 1 (DELETE): "DELETE FROM lix_file WHERE id IN (?1)" → params: [param[0]]
Statement 2 (INSERT): "INSERT ... VALUES (?1, ?1, ?1)"        → params: [param[1], param[2], param[3]]
Statement 3 (UPDATE): "UPDATE ... SET path = ?1, data = ?1 WHERE id = ?1" → params: [param[4], param[5], param[6]]
```

**Step 2** — Each statement is passed to `execute_with_options_in_transaction()` (`in_transaction.rs:16`), which re-parses the SQL and runs it through the full preprocessing pipeline (`pipeline.rs`), which calls `render_statements_with_params()` (`pipeline.rs:287`), which calls `bind_sql_with_state_and_appended_params()` **again**.

The second binding sees `?1` placeholders in already-bound SQL. Because the params array is now just the statement's slice (e.g., `[param[1], param[2], param[3]]`), the `?1` correctly maps to `param[1]`, `?2` to `param[2]`, etc. — BUT this only works if:

1. The first binding produced strictly sequential `?1, ?2, ?3` (no deduplication)
2. The preprocessing rewrite didn't insert additional placeholders
3. No appended_params were generated by the rewrite

If any of these assumptions break, parameters silently map to wrong values.

---

## Root Cause #2: Side Effects Collected Before Parameter Resolution

In `entry.rs:127-137` and `in_transaction.rs:61-71`:

```rust
// Side effects collected HERE (before preprocessing)
let side_effects = self.collect_execution_side_effects_with_backend_from_statements(
    &backend,
    &parsed_statements,
    params,                    // raw params, not yet bound
    &active_version_id,
    writer_key,
    ...
).await?;

// Preprocessing happens LATER
let output = preprocess_parsed_statements_with_provider_and_detected_file_domain_changes(
    ...
).await;
```

The side effect collector must independently interpret placeholder parameters in the raw SQL to determine what file operations will happen. If the collector's interpretation diverges from how `bind_sql_with_state` resolves the same placeholders, side effects are wrong.

---

## Root Cause #3: Dead Deferred Side Effects Path

`scripts.rs:73`:
```rust
let can_defer_side_effects = false;  // ALWAYS FALSE
```

This means the entire deferred side effects mechanism (lines 74-103) is dead code. Every statement in a transaction script independently:
1. Collects its own side effects
2. Persists file domain changes
3. Invalidates file caches

This is both slower (N side-effect collections instead of 1) and more error-prone (intermediate states may be inconsistent).

---

## Root Cause #4: Opaque Fallback Conditions

`fallback.rs` defines when the sequential fallback triggers:

```rust
fn should_sequentialize_postprocess_multi_statement_with_statements(
    statements: &[Statement],
    params: &[Value],
    error: &LixError,
) -> bool {
    if !params.is_empty() { return false; }  // ONLY for parameterless queries
    if !is_postprocess_multi_statement_error(&error.message) { return false; }
    if statements.len() <= 1 { return false; }
    // No transaction statements
    true
}
```

Key observations:
- The fallback **only** works for parameterless queries (`!params.is_empty()` guard)
- It triggers on string-matching error messages ("postprocess rewrites require a single statement")
- If someone changes an error message, the fallback silently stops working
- The fallback re-enters the full execution pipeline for each statement, creating recursive execution

---

## Root Cause #5: Coalescing Optimizations Create Divergent Behavior

`scripts.rs:65-128` has **three completely different processing paths** based on whether params are empty:

```
params.is_empty()?
├─ YES → coalesce_lix_file_transaction_statements() [SQLite only]
│        Falls through to: coalesce_vtable_inserts_in_statement_list()
└─ NO  → bind_sql_with_state() per statement [both dialects]
```

And `coalesce_lix_file_transaction_statements()` (`rewrite.rs:60-179`) is a completely separate SQL generation path that:
- Only works on SQLite
- Only handles `lix_file` table operations
- Generates raw SQL strings with escaped literals (no parameters)
- Requires specific statement ordering (deletes before inserts before updates)

When this optimization returns `None` (e.g., on Postgres, or unsupported statement patterns), the system silently falls through to a different path. A query that works on SQLite may fail on Postgres because the coalescing optimization doesn't apply.

---

## Specific Regression-Prone Code Patterns

### 1. Deduplication in params.rs can renumber placeholders

`bind_sql_with_state_and_appended_params()` uses a `source_to_dense` HashMap to deduplicate parameter references. If SQL uses `$1, $1, $3`, the output is renumbered to `$1, $1, $2` with only 2 params.

When this happens in the **first** binding (scripts.rs), the SQL emitted has non-sequential placeholder numbers. The **second** binding (pipeline.rs) then re-interprets these, potentially creating incorrect mappings.

### 2. PlaceholderState.next_ordinal carries across statements

```rust
// params.rs:130-133
let source_index = state.next_ordinal;
state.next_ordinal += 1;
```

For explicit indices (`?3`, `$3`):
```rust
// params.rs:135-137
state.next_ordinal = state.next_ordinal.max(parsed);  // jumps forward
parsed - 1
```

If one statement uses explicit `?3`, `next_ordinal` jumps to 3, meaning the next statement's `?` starts at index 3. This is correct when all params are in a single flat array, but fragile — if any caller changes the params array shape, ordinals break.

### 3. render_statements_with_params returns empty params for multi-statement

`pipeline.rs:313-317`:
```rust
let compatibility_params = if prepared_statements.len() == 1 {
    prepared_statements[0].params.clone()
} else {
    Vec::new()  // ← EMPTY for multi-statement
};
```

The `PreprocessOutput.params` field is empty for multi-statement queries. Callers that use `output.params` (e.g., `build_delete_followup_sql` in `in_transaction.rs:218`) get an empty vec. This is worked around by also accessing `output.prepared_statements[i].params`, but it's a footgun.

### 4. Each in-transaction statement execution re-parses SQL

`in_transaction.rs:16`:
```rust
let parsed_statements = parse_sql_statements(sql)?;
```

SQL that was already parsed, rewritten, lowered, and bound in scripts.rs gets serialized back to a string, then re-parsed, re-analyzed, and re-preprocessed. This round-trip can introduce semantic drift if `Statement::to_string()` doesn't perfectly preserve the SQL semantics.

---

## Proposed First-Principles Architecture

### Principle 1: Single Execution Path

Every SQL execution should flow through **one** pipeline with explicit phases. No branching into separate execution paths.

```
parse → analyze → bind_params → rewrite → lower → execute → postprocess → side_effects
```

Transaction scripts (BEGIN...COMMIT) should be detected early and the inner statements should flow through the same pipeline — not get routed to a completely separate module.

### Principle 2: Bind Parameters Exactly Once

Parameters should be resolved to concrete values at a single point in the pipeline, never re-bound. After binding, statements carry their concrete `PreparedStatement { sql, params }` form through all subsequent phases.

### Principle 3: Side Effects Derived from Execution Results, Not Pre-Computed

Instead of pre-computing side effects from raw SQL (which requires duplicating the parameter resolution logic), derive side effects from the actual executed statements and their results. This eliminates the timing/ordering problem entirely.

### Principle 4: No String-Based Error Matching for Control Flow

The sequential fallback triggers on `error.message == "postprocess rewrites require a single statement"`. Replace with typed error variants:

```rust
enum PreprocessError {
    PostprocessMultiStatement { statements: Vec<Statement> },
    InvalidSql(String),
    // ...
}
```

### Principle 5: Dialect Differences Isolated to Lowering Phase

The `coalesce_lix_file_transaction_statements` optimization is SQLite-only and creates a completely separate code path. Dialect-specific behavior should be confined to the lowering phase, not scattered across the execution path selection.

---

## Concrete Refactoring Steps

### Step 1: Unify the Parameter Binding

Create a `BoundStatementBlock` that represents a fully-bound set of statements:

```rust
struct BoundStatementBlock {
    statements: Vec<PreparedStatement>,  // Each has its own sql + params
    is_transaction: bool,
}
```

Bind parameters **once** in `scripts.rs`/`entry.rs`, then pass `BoundStatementBlock` to all subsequent phases. The preprocessing pipeline should accept pre-bound statements and NOT re-bind.

### Step 2: Eliminate the Second Parse+Preprocess in the Transaction Script Path

Instead of:
```
scripts.rs: parse → bind → for each: serialize → in_transaction.rs: parse → preprocess → execute
```

Do:
```
scripts.rs: parse → bind → preprocess each → execute each
```

This removes the serialize→re-parse round-trip and the double-binding.

### Step 3: Make Side Effect Collection a Post-Execution Phase

Move from:
```
collect_side_effects(raw_sql, params) → preprocess → execute → persist_side_effects
```

To:
```
preprocess → execute → collect_side_effects(executed_statements, results) → persist_side_effects
```

### Step 4: Replace String-Matched Fallback with Typed Pipeline Stages

Instead of catching a string error and falling back:
```rust
match preprocess(statements) {
    Ok(output) => execute(output),
    Err(e) if is_postprocess_error(&e.message) => fallback(statements),
}
```

Use a typed preprocessing result:
```rust
enum PreprocessResult {
    Ready(PreprocessOutput),
    NeedsSequentialExecution(Vec<Statement>),  // multi-statement with postprocess
}
```

### Step 5: Consolidate Transaction Handling

Replace the 5 paths with 2:
1. **Single-statement**: parse → preprocess → execute
2. **Multi-statement** (including `BEGIN...COMMIT`): parse → bind per-statement → for each: preprocess → execute (all within a single transaction)

The `engine.transaction(|tx| ...)` API should compose on top of path 2, not be a separate path.

---

## Risk Assessment of Current Tests

| Test | What It Covers | What It Misses |
|------|---------------|----------------|
| `transaction_path_applies_insert_validation` | Schema validation in txn | Parameterized validation |
| `transaction_path_respects_deterministic_settings` | Deterministic UUID/timestamp | Interaction with param binding |
| `transaction_path_applies_multi_statement_postprocess_fallback` | Sequential fallback | Parameterized fallback (skipped by guard) |
| `transaction_script_path_preprocesses_lix_file_statements` | lix_file in BEGIN/COMMIT | Only empty params |
| `transaction_path_handles_large_vtable_insert_batch_without_sqlite_variable_overflow` | SQLite variable limit | Postgres path |
| `transaction_script_path_handles_large_parameterized_batch_without_param_fanout_oom` | OOM prevention | Only SELECT (no rewrites) |
| `transaction_script_path_handles_parameterized_lix_file_update_with_prior_statement_params` | Param carryover across statements | Doesn't test deduplication edge cases |
| `transaction_path_rolls_back_when_callback_panics` | Panic rollback | Clean |

### Missing Test Coverage
- Parameterized multi-statement with postprocess (fallback guard prevents this)
- Parameter deduplication across statements (`?1` reused in different statements)
- Postgres-specific transaction script path with parameters
- Appended params from rewrite + user params in same statement
- Coalescing fallthrough behavior (SQLite optimization returns None)
- Side effect accuracy with parameterized statements
